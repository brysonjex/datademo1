import argparse
from pathlib import Path

import pandas as pd


def find_date_columns(df: pd.DataFrame) -> list[str]:
    date_columns = []
    for col in df.columns:
        series = df[col]
        if pd.api.types.is_datetime64_any_dtype(series):
            date_columns.append(col)
            continue
        if series.dtype == object:
            parsed = pd.to_datetime(series, errors="coerce")
            if parsed.notna().sum() > 0:
                date_columns.append(col)
    return date_columns


def summarize_sheet(df: pd.DataFrame, sheet_name: str, output_dir: Path) -> dict:
    summary = {
        "sheet": sheet_name,
        "rows": int(df.shape[0]),
        "columns": int(df.shape[1]),
    }

    column_summary = (
        df.describe(include="all")
        .transpose()
        .rename_axis("column")
        .reset_index()
    )
    column_summary.to_csv(output_dir / f"{sheet_name}_column_summary.csv", index=False)

    numeric_cols = df.select_dtypes(include="number")
    if not numeric_cols.empty:
        numeric_stats = numeric_cols.describe().transpose().reset_index().rename(columns={"index": "column"})
        numeric_stats.to_csv(output_dir / f"{sheet_name}_numeric_stats.csv", index=False)
    else:
        (output_dir / f"{sheet_name}_numeric_stats.csv").write_text("column,count,mean,std,min,25%,50%,75%,max\n")

    date_cols = find_date_columns(df)
    date_ranges = []
    for col in date_cols:
        parsed = pd.to_datetime(df[col], errors="coerce")
        if parsed.notna().any():
            date_ranges.append(
                {
                    "column": col,
                    "min_date": parsed.min().date().isoformat(),
                    "max_date": parsed.max().date().isoformat(),
                    "non_null": int(parsed.notna().sum()),
                }
            )
    pd.DataFrame(date_ranges).to_csv(output_dir / f"{sheet_name}_date_ranges.csv", index=False)

    return summary


def markdown_table(df: pd.DataFrame) -> str:
    headers = [str(col) for col in df.columns]
    rows = df.astype(str).values.tolist()
    header_line = "| " + " | ".join(headers) + " |"
    separator_line = "| " + " | ".join(["---"] * len(headers)) + " |"
    row_lines = ["| " + " | ".join(row) + " |" for row in rows]
    return "\n".join([header_line, separator_line, *row_lines])


def main() -> None:
    parser = argparse.ArgumentParser(description="Analyze a JE Excel sample file.")
    parser.add_argument("--input", default="je_samples.xlsx", help="Path to the Excel file.")
    parser.add_argument("--output", default="analysis_output", help="Directory to write analysis outputs.")
    args = parser.parse_args()

    input_path = Path(args.input)
    output_dir = Path(args.output)
    output_dir.mkdir(parents=True, exist_ok=True)

    excel = pd.ExcelFile(input_path)
    summary_rows = []

    for sheet_name in excel.sheet_names:
        df = pd.read_excel(input_path, sheet_name=sheet_name)
        summary_rows.append(summarize_sheet(df, sheet_name, output_dir))

    summary_df = pd.DataFrame(summary_rows)
    summary_df.to_csv(output_dir / "sheet_summary.csv", index=False)

    summary_lines = [
        "# JE Sample Analysis Summary",
        "",
        f"Input file: `{input_path}`",
        "",
        "## Sheet Overview",
        markdown_table(summary_df),
        "",
        "## Outputs",
        "- `sheet_summary.csv`: row/column counts per sheet",
        "- `<sheet>_column_summary.csv`: descriptive stats for all columns",
        "- `<sheet>_numeric_stats.csv`: numeric summary stats",
        "- `<sheet>_date_ranges.csv`: date range summaries",
        "",
        "Generated by `scripts/analyze_je_samples.py`.",
    ]

    (output_dir / "summary.md").write_text("\n".join(summary_lines))


if __name__ == "__main__":
    main()
